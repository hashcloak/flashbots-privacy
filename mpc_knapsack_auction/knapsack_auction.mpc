
program.use_edabit(True)
sfix.round_nearest = True
cfix.set_precision(f=10, k=25)
sfix.set_precision(f=10, k=25)

class Bidder:
    def __init__(self, id, bids, block_spaces):
        self.bidder_id = id
        self.bids = bids
        self.wanted_block_spaces = block_spaces
        self.factors = []

        # The list of bids and block space have the same lenght
        for i in range(len(bids)):
            self.factors.append(sfix(bids[i] / block_spaces[i]))

def knapsack_auction(bidders, max_block_space, highest_bidder): 
    actual_capacity_of_solution = MemValue(sfix(0))
    actual_solution = []
    #global counter
    #counter = MemValue(0)
    n_bidders = bidders.sizes[0]

    @for_range(n_bidders)
    def _(i):
        #nonlocal actual_capacity_of_solution
        current_bidder = bidders[i]
        capacity_to_add = (actual_capacity_of_solution + current_bidder[2] <= max_block_space).if_else(current_bidder[2], 0)
        bidder_to_add = (actual_capacity_of_solution + current_bidder[2] <= max_block_space).if_else(current_bidder, False)
        actual_solution.append(bidder_to_add)
        actual_capacity_of_solution.iadd(capacity_to_add)
        

    surplus = 0
    for winner in actual_solution:
        surplus += winner[1]

    @if_e(highest_bidder[1].reveal() > surplus.reveal())
    def _():
        print_ln("Winner is bidder %s with bid %s and wanted block space %s", highest_bidder[3].reveal(), highest_bidder[2].reveal(), highest_bidder[1].reveal())
    @else_
    def _():
        print_ln("Knapsack Auction Winners:")
        for bidder in actual_solution:
            if bidder is not False:
                print_ln("%s %s %s", bidder[0].reveal(), bidder[1].reveal(), bidder[2].reveal())

n = int(program.args[1])
W = int(program.args[2])
tx_per_party = int(program.args[3])

bidders = []
for i in range(n):
    bids = sfix.get_input_from(i, size=tx_per_party)
    block_spaces = sfix.get_input_from(i, size=tx_per_party)
    bidders.append(Bidder(i, bids, block_spaces))

bidder_matrix = sfix.Matrix(n * tx_per_party, 4)
counter = 0
for bidder in bidders:
    for i in range(tx_per_party):
        vec = sfix.Array(4)
        vec.assign([bidder.bidder_id, bidder.bids[i], bidder.wanted_block_spaces[i], bidder.factors[i]])
        bidder_matrix[counter] = vec.get_reverse_vector()
        counter += 1

bidder_matrix.sort()
highest_bidder = bidder_matrix[0]

knapsack_auction(bidder_matrix, W, highest_bidder)
