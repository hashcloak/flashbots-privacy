import sys
from Compiler.oram import OptimalORAM
from Compiler.types import cfix

def max_knapsack(values, weights, W, n):
    size = n*W
    m = OptimalORAM((n+1)*(W+1))

    for i in range(n + 1):
        for j in range(W + 1):
            @if_e(i == 0 or j == 0)
            def _():
                m[i*(W+1) + j] = 0
            @else_
            def _():
                condition = weights[i-1] > j
                outcome1 = m[(i-1)*(W+1) + j]
                outcome2 = sint(m[(i-1)*(W+1) + j]).max(m[(i-1)*(W+1)+(j-weights[i-1])] + values[i-1])
                m[i * (W+1) + j] = condition.if_else(outcome1, outcome2)

    return (m[(n)*(W+1)+(W)], m)

def knapsack_subset(index_i, index_j, m, weights):
    subset = OptimalORAM(3)
    W = index_j
    if index_i == 0:
        return
    counter = MemValue(0)
    while (index_i != 0):
        subset[counter] = (m[index_i * (W+1)+index_j] > m[(index_i-1)*(W+1) + index_j]).if_else(index_i, subset[counter])

        counter += 1
        index_i -= 1

    return subset


# Ideally, W should be secret-shared but due to MP-SPDZ limitations, need it to be a compile time constant
W = int(program.args[2])
# Ideally, n should be a secret-shared value as we typically don't know upfront how many txs are yet to be included in a block.
# This is just to get around MP-SPDZ limitations around compile time sizes
n = int(program.args[1])
tx_per_party = int(program.args[3])

values_tmp = []
weights_tmp = []

for i in range(n):
    values_tmp.extend(sint.get_input_from(i, size=tx_per_party))
    weights_tmp.extend(sint.get_input_from(i, size=tx_per_party))

values = Array(n, sint).create_from(values_tmp)
weights = Array(n, sint).create_from(weights_tmp)

knapsack_val, m = max_knapsack(values, weights, W, n)
knapsack_subset = knapsack_subset(n, W, m, weights)
print_ln("Maximal knapsack value: %s", knapsack_val.reveal())
for i in range(knapsack_subset.size):
    print_ln("Corresponding knapsack set index %s", knapsack_subset[i].reveal())
